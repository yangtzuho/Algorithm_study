# 费解的开关
## 题目描述
你玩过“拉灯”游戏吗？25 盏灯排成一个 5×5 的方形。每一个灯都有一个开关，游戏者可以改变它的状态。
每一步，游戏者可以改变某一个灯的状态。游戏者改变一个灯的状态会产生连锁反应：和这个灯上下左右相邻的灯也要相应地改变其状态。
我们用数字 1 表示一盏开着的灯，用数字 0 表示关着的灯。下面这种状态
![image](https://user-images.githubusercontent.com/45890998/163699231-c065e7a3-4d0e-4d4e-9519-6fe3101f2921.png)
给定一些游戏的初始状态，编写程序判断游戏者是否可能在 6 步以内使所有的灯都变亮。

## 输入格式
第一行输入正整数 n，代表数据中共有 n 个待解决的游戏初始状态。以下若干行数据分为 n 组，每组数据有 5 行，每行 5 个字符。每组数据描述了一个游戏的初始状态
各组数据间用一个空行分隔。

## 输出格式
一共输出 n 行数据，每行有一个小于等于 6 的整数，它表示对于输入数据中对应的游戏状态最少需要几步才能使所有灯变亮。对于某一个游戏初始状态，若 6 步以内无法使所有灯变亮，则输出 −1。

**数据范围**
0<n≤500

## 题解
该题目有两种性质：
1. 摁开关的顺序可以任意
2. 每个格子最多只能摁一次（摁两次相当于没摁）

假如我们先枚举第一行第一行操作完以后，假如有两个格子是暗的，由于现在只有摁第二行能够改变第一行的状态，所以第二行所能操作的开关的位置就是固定的（即第二行的摁法是唯一确定的）
**关键**：
第一行的状态决定了第二行的摁法，第二行的状态决定了第三行的摁法（如果该行的某个格子是暗的，下一行的该位置就必须摁，如果该行的某个格子是亮的，下一行该位置就必须不能摁）
每一行的开关操作完全被上一行灯的亮灭状态所唯一确定。
最后一行的状态由之前的操作确定，要是最后一行的全亮，则该方案合法，否则该方案不合法

**细节**
1. 如何枚举第一行的操作？利用位运算技巧循环
2. turn(x,y)改变状态的函数
```c++
#include <iostream>
#include <cstring>
#include <algorithm>
using namespace std;

const int N = 6;
char g[N][N], backup[N][N];
int dx[5] = { -1, 0, 1, 0, 0 }, dy[5] = { 0, 1, 0, -1, 0 };

void turn(int x, int y)
{
	for (int i = 0; i < 5; i++)
	{
		int a = x + dx[i], b = y + dy[i];
		if (a < 0 || a >= 5 || b < 0 || b >= 5) continue;//出界了
		g[a][b] ^= 1;
	}
}

int main()
{
	int T;//测试数据的数量
	cin >> T;
	while (T--)
	{
		for (int i = 0; i < 5; i++) cin >> g[i];
		int res = 10;

		//枚举第一行的操作
		for (int op = 0; op < 32; op++)
		{
			//在备份上进行操作
			memcpy(backup, g, sizeof g);
			int step = 0;//记录最小步数
			for (int i = 0; i < 5; i ++)
				if (op >> i & 1)
				{
					step++;
					turn(0, i);
				}
			//第一行操作完之后，枚举到倒数第二行
			for (int i = 0; i < 4; i++)
				for (int j = 0; j < 5; j++)
					//如果当前灯的状态是灭的话，说明下一行的当前位置一定要摁开关
					if (g[i][j] == '0')
					{
						step++;
						turn(i + 1, j);
					}

			bool dark = false;//判断最后一行是否全亮
			for (int i = 0; i < 5; i ++)
				if (g[4][i] == '0')
				{
					dark = true;
					break;
				}
			if (!dark) res = min(res, step);
			memcpy(g, backup, sizeof g);
		}

		if (res > 6) res = -1;
		cout << res << endl;

	}

	system("pause");
	return 0;
}
```
